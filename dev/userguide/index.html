<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · Kernel Density Estimation</title><meta name="title" content="User Guide · Kernel Density Estimation"/><meta property="og:title" content="User Guide · Kernel Density Estimation"/><meta property="twitter:title" content="User Guide · Kernel Density Estimation"/><meta name="description" content="Documentation for Kernel Density Estimation."/><meta property="og:description" content="Documentation for Kernel Density Estimation."/><meta property="twitter:description" content="Documentation for Kernel Density Estimation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Kernel Density Estimation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Kernel Density Estimation</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Simple-kernel-density-estimate"><span>Simple kernel density estimate</span></a></li><li><a class="tocitem" href="#Densities-with-boundaries"><span>Densities with boundaries</span></a></li><li><a class="tocitem" href="#Densities-of-weighted-samples"><span>Densities of weighted samples</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Package Extensions</a></li><li><a class="tocitem" href="../explain/">Explanation</a></li><li><a class="tocitem" href="../showcase/">Showcase</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h1><ul><li><a href="#Getting-Started">Getting Started</a></li><li><a href="#Simple-kernel-density-estimate">Simple kernel density estimate</a></li><li><a href="#Densities-with-boundaries">Densities with boundaries</a></li><li><a href="#Densities-of-weighted-samples">Densities of weighted samples</a></li></ul><h2 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h2><p>To install KernelDensityEstimation.jl, it is recommended that you use the <a href="https://github.com/jmert/Registry.jl">jmert/Registry.jl</a> package registry, which will let you install (and depend on) the package similarly to any other Julia package in the default General registry.</p><pre><code class="language-julia-repl hljs">pkg&gt; registry add https://github.com/jmert/Registry.jl

pkg&gt; add KernelDensityEstimation</code></pre><h2 id="Simple-kernel-density-estimate"><a class="docs-heading-anchor" href="#Simple-kernel-density-estimate">Simple kernel density estimate</a><a id="Simple-kernel-density-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-kernel-density-estimate" title="Permalink"></a></h2><p>For the following example, we&#39;ll use a small sample of Gaussian deviates:</p><pre><code class="language-julia hljs">using KernelDensityEstimation
x = 3 .+ 0.1 .* randn(250) # x ~ Normal(3, 0.1)</code></pre><p>The key interface of this package is the <a href="../api/#KernelDensityEstimation.kde"><code>kde</code></a> function. In its simplest incantation, you provide a vector of data and it returns a kernel density object (in the form of a <a href="../api/#KernelDensityEstimation.UnivariateKDE"><code>UnivariateKDE</code></a> structure).</p><pre><code class="language-julia hljs">using KernelDensityEstimation

K = kde(x)</code></pre><p>The density estimate <span>$f(x)$</span> is given at locations <code>K.x</code> (as a <a href="https://docs.julialang.org/en/v1/base/math/#Base.StepRangeLen"><code>StepRangeLen</code></a>) with density values <code>K.f</code>. For instance, the mean and variance of the distribution are:</p><pre><code class="language-julia hljs">μ1 = step(K.x) * sum(@. K.f * K.x)
μ2 = step(K.x) * sum(@. K.f * K.x^2)

(; mean = μ1, std = sqrt(μ2 - μ1^2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(mean = 2.9986807890073575, std = 0.11013630728702606)</code></pre><p>which agree well with the known underlying parameters <span>$(\mu = 3, \sigma = 0.1)$</span>.</p><p>Visualizing the density estimate (see <a href="../extensions/#ext-makie">Extensions — Makie.jl</a>), we see a fair level of consistency between the density estimate and the known underlying model.</p><p><img src="../getting_started_1.svg" alt/></p><h2 id="Densities-with-boundaries"><a class="docs-heading-anchor" href="#Densities-with-boundaries">Densities with boundaries</a><a id="Densities-with-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Densities-with-boundaries" title="Permalink"></a></h2><p>The previous example arises often and is handled well by most kernel density estimation solutions. Being a Gaussian distribution makes it particularly well behaved, but in general distributions which are unbounded and gently fade away to zero towards <span>$\pm\infty$</span> are relatively easy to deal with. Despite how often the Gaussian distribution is an appropriate [approximation of the] distribution, there are still many cases where various bounded distributions are expected, and ignoring the boundary conditions can lead to a very poor density estimate.</p><p>Take the simple case of the uniform distribution on the interval <span>$[0, 1]$</span>.</p><pre><code class="language-julia hljs">x = rand(5_000)</code></pre><p>By default, <code>kde</code> assumes the distribution is unbounded, and this leads to &quot;smearing&quot; the density across the known boundaries to the regions <span>$x &lt; 0$</span> and <span>$x &gt; 1$</span>:</p><pre><code class="language-julia hljs">K0 = kde(x)</code></pre><p><img src="../getting_started_unbound_unif.svg" alt/></p><p>We can inform the estimator that we expect a bounded distribution, and it will use that information to generate a more appropriate estimate. To do so, we make use of three keyword arguments in combination:</p><ol><li><code>lo</code> to dictate the lower bound of the data.</li><li><code>hi</code> to dictate the upper bound of the data.</li><li><code>boundary</code> to specify the boundary condition, such as <code>:open</code> (unbounded), <code>:closed</code> (finite), and half-open intervals <code>:closedleft</code>/<code>:openright</code> and <code>:closedright</code>/<code>:openright</code>.</li></ol><p>In this example, we know our data is bounded on the closed interval <span>$[0, 1]$</span>, so we can improve the density estimate by providing that information</p><pre><code class="language-julia hljs">K1 = kde(x, lo = 0, hi = 1, boundary = :closed)</code></pre><p><img src="../getting_started_limit_unif.svg" alt/></p><p>Note that in addition to preventing the smearing of the density beyond the bounds of the known distribution, the density estimate with correct boundaries is also smoother than the unbounded estimate. This is because the sharp drops at <span>$x = \{0, 1\}$</span> no longer need to be represented, so the algorithm is no longer compromising on smoothing the interior of the distribution with retaining the cut-offs.</p><div class="admonition is-category-hint"><header class="admonition-header">Hint</header><div class="admonition-body"><p>In addition to the aforementioned triple of <code>lo</code>, <code>hi</code>, and <code>boundary</code> keywords, there is a single <code>bounds</code> keyword which can replace all three. The built-in mechanism only accepts a tuple where <code>bounds = (lo, hi, boundary)</code>, but the additional keyword makes it possible to customize behavior for new types of arguments. For example, there is a <a href="../extensions/#ext-distributions">package extension for <code>Distributions.jl</code></a> which allows using the support of a distribution to automatically infer appropriate boundary conditions and limits.</p><p>See the docstring for <a href="../api/#KernelDensityEstimation.kde"><code>kde</code></a> (and references therein) for more information.</p></div></div><h2 id="Densities-of-weighted-samples"><a class="docs-heading-anchor" href="#Densities-of-weighted-samples">Densities of weighted samples</a><a id="Densities-of-weighted-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Densities-of-weighted-samples" title="Permalink"></a></h2><p>In some cases, the data to be analyzed is a <em>weighted</em> vector of data (represented as a vector of data and a corresponding vector of weight factors). For instance, <a href="https://en.wikipedia.org/wiki/Importance_sampling">importance sampling</a> of an <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">MCMC</a> chain results in non-uniform weights that then must be considered when deriving a density estimate.</p><p>Take the following toy example where we have a target parameter <span>$v$</span> and nuisance parameter <span>$p$</span> that are correlated, where a uniform prior was assumed for <span>$p$</span>:</p><pre><code class="language-julia hljs"># correlation coefficient and nuisance parameter
ρ, p = 0.85, randn(500)
# correlated target parameter
v = ρ .* p .+ sqrt(1 - ρ^2) .* randn.()</code></pre><p>Now suppose that you have reason to update your prior on <span>$p$</span>, believing now that positive values are twice as likely as negative ones. If the method of generating <span>$v$</span> is expensive, and because the change in prior is not extreme, it may be efficient and acceptable to instead importance sample the existing values by reweighting the samples by the ratio of the priors:</p><p class="math-container">\[\begin{align*}
P_1(p) &amp;\propto 1
&amp;
P_2(p) &amp;\propto \begin{cases}
    1 &amp; p &lt; 0 \\
    2 &amp; p \ge 0 \\
    \end{cases}
\end{align*}\]</p><pre><code class="language-julia hljs">P1(z) = 1.0
P2(z) = z ≥ 0 ? 2.0 : 1.0
weights = P2.(p) ./ P1.(p)</code></pre><p>We then simply provide these weights as a keyword argument in the call to <code>kde</code>:</p><pre><code class="language-julia hljs">K1 = kde(v)
K2 = kde(v; weights)</code></pre><p><img src="../getting_started_weighting.svg" alt/></p><p>As expected, this shifts the resultant density estimate to the right, toward more positive values.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The effective sample size (<a href="../api/#KernelDensityEstimation.UnivariateKDEInfo"><code>UnivariateKDEInfo.neffective</code></a>) is calculated from the weights using <a href="https://search.r-project.org/CRAN/refmans/svyweight/html/eff_n.html">Kish&#39;s definition</a>. Both of the bandwidth estimators (<a href="../api/#KernelDensityEstimation.SilvermanBandwidth"><code>SilvermanBandwidth</code></a> and <a href="../api/#KernelDensityEstimation.ISJBandwidth"><code>ISJBandwidth</code></a>) use this definition in scaling the bandwidth with the (effective) sample size.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Kernel Density Estimation</a><a class="docs-footer-nextpage" href="../extensions/">Package Extensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 13 January 2025 01:49">Monday 13 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
